# 코딩테스트(파이썬)

### 그리디(Greedy)

현재 상황에서 지금 당장 좋은 것만 고르는 방법

대부분의 그리디 알고리즘 문제는 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다.
문제를 읽고 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고 고민해 보아야 한다.

---

### 구현(Implementaion)

머리속에 있는 알고리즘을 소스코드로 바꾸는 과정

따라서 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.

- 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법

파이썬은 구현 상의 복잡함은 적은 편이지만 데이터 처리량이 많을 때는 꼭 메모리 제한을 고려해야 한다.

- 파이썬에서 리스트의 크기

1,000개 -> 4KB, 1,000,000(백만) -> 4MB, 10,000,000(천만) -> 40MB

메모리 제한 뿐만 아니라 시간 제한도 고려해야 하는데, 1초에 2000만번의 연산을 수행한다고 가정하면 크게 무리가 없다.
따라서 만약 데이터의 개수가 100만개라면, NlogN의 시간복잡도를 가지는 알고리즘을 이용하여 풀어야 한다.
Pypy3를 지원한다면 1초에 2000만 번에서 1억 번 정도의 연산을 처리할 수 있다.

---

### DFS / BFS

- 스택(Stack) : 먼저 들어간 데이터가 나중에 나오는 FILO(First In Last Out)구조
  파이썬 내에서는 기본 리스트에서 append()와 pop()메소드를 사용하면 된다.

- 큐(Queue) : 먼저 들어간 데이터가 먼저 나오는 FIFO(First In First Out)구조
  collections모듈에서 제공하는 deque 자료구조를 통해 큐를 구현할 수 있다.
  append()와 popleft(), reverse() 함수 등이 있다.

- 재귀 함수(Recursive Function) : 재귀 함수란 함수 내에서 자기 자신을 호출하는 함수
  재귀 함수는 반드시 종료 조건을 명시해 주어야 한다.

- 그래프(Graph) : 그래프는 노드(Node, 또는 정점 Vertex)와 간선(Edge)로 이루어진다.
  각 노드들이 연결되어 있는 것을 인접하다(Adjacent)라고 하며 그래프를 표현하는 방식은 크게 2가지가 있다.

  - 인접 행렬(Adjacent Matrix) : 그래프를 2차원 행렬로 표현한 방식으로 메모리가 많이 사용되지만 특정한 두 노드의 연결성을 빠르게 확인할 수 있다.

  - 인접 리스트(Adjacent List) : 그래프를 연결된 정보만을 저장하기 때문에 효율적이지만 특정한 두 노드의 연결성을 확인하는데 인접 행렬보다 느리지만 특정 노드부터 인접한 모든 노드를 방문해야 하는 경우에는 효율적이다.

##### DFS(깊이 우선 탐색)

그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘으로 모든 데이터를 탐색하는데 O(N)의 시간이 소요된다.

1. 탐색 시작 노드를 스택에 넣고 방문처리 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 인접 노드를 스택에 넣고 방문 처리한다. 방문하지 않은 인접 노드가 없다면 스택에서 최상단 노드를 꺼낸다.
3. 1,2의 과정을 반복한다.

재귀함수를 이용할 경우 스택을 사용하지 않고 구현 가능하며 더 간결해진다. 그렇지만 컴퓨터 시스템의 동작 특성상 실제 프로그램의 수행 시간은 느려질 수 있다. 따라서 스택을 이용하여 수행 시간을 완화하는 방법도 필요하다.

##### BFS(너비 우선 탐색)

그래프에서 가까운 노드부터 탐색하는 알고리즘으로 DFS와 마찬가지로 모든 데이터를 탐색하는데 O(N)의 시간이 소요된다.
하지만 일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이다.

1. 탐색 노드를 큐에 넣고 방문처리 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 넣고 방문처리 한다.
3. 2의 과정을 수행할 수 없을 때까지 반복한다.

---
