# BaekJoon3190
#  'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다.
# 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.

# 게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다.
# 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.

# 뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.

# 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
# 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.
# 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.
# 사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.

# 입력
# 첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)

# 다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.

# 다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)

# 다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며.
# 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다.
# X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.

# 출력
# 첫째 줄에 게임이 몇 초에 끝나는지 출력한다.

# 6
# 3
# 3 4
# 2 5
# 5 3
# 3
# 3 D
# 15 L
# 17 D

# 10
# 4
# 1 2
# 1 3
# 1 4
# 1 5
# 4
# 8 D
# 10 D
# 11 D
# 13 L

# 10
# 5
# 1 5
# 1 3
# 1 2
# 1 6
# 1 7
# 4
# 8 D
# 10 D
# 11 D
# 13 L
from collections import deque

# 방향 전환


def turn(cd, dirction):
    if dirction == 'D':
        nd = (cd + 1) % 4
    else:
        nd = (cd + 3) % 4
    return nd


n = int(input())
k = int(input())

# 맵 초기화
board = [[0]*n for _ in range(n)]

# 사과 위치 초기화
for _ in range(k):
    row, col = map(int, input().split())
    board[row - 1][col - 1] = 1


# 방향 전환 정보 입력받기
l = int(input())
# 방향 전환 정보를 priority queue에 담아 시간에 따라 오름차순 정렬
direction = deque()
for _ in range(l):
    time, d = input().split()
    direction.append((int(time), d))

# 북 동 남 서에 따른 각각 전진시 변화량
dx = [0, 1, 0, -1]
dy = [-1, 0, 1, 0]
# 현재 방향
cd = 1
# 뱀의 위치를 q에 담음
q = deque()
q.append((0, 0))

# 맵에 현재 위치 표시
board[0][0] = 2

# 시간
time = 0
while True:
    # 다음 위치 찾기
    ny = q[-1][0] + dy[cd]
    nx = q[-1][1] + dx[cd]

    # 맵을 벗어나거나 자기 자신을 만난다면 죽음
    if nx >= n or ny >= n or nx < 0 or ny < 0 or board[ny][nx] == 2:
        time += 1
        break

    # 사과를 먹은게 아니라면 가장 오래된 뱀의 위치를 제거
    if board[ny][nx] != 1:
        loc = q.popleft()
        board[loc[0]][loc[1]] = 0

    # 뱀의 위치 추가
    q.append((ny, nx))
    board[ny][nx] = 2

    # 시간 증가
    time += 1

    # 시간이 방향전환정보에 데이터의 최근 정보와 일치한다면
    if len(direction) != 0 and time == direction[0][0]:
        # 해당 정보를 없애고
        d = direction.popleft()[1]
        # 방향전환
        cd = turn(cd, d)

print(time)
